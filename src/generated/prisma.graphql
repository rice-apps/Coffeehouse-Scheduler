# source: https://us1.prisma.sh/will-mundy-9280b5/chaus-gql/dev
# timestamp: Mon Jul 02 2018 01:30:49 GMT+0800 (HKT)

type AggregateDay {
  count: Int!
}

type AggregateSchedule {
  count: Int!
}

type AggregateShift {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type AggregateUserAvailability {
  count: Int!
}

type BatchPayload {
  """The number of nodes that have been affected by the Batch operation."""
  count: Long!
}

type Day implements Node {
  id: ID!
  dayName: WEEKDAY!
  shifts(where: ShiftWhereInput, orderBy: ShiftOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Shift!]
}

"""A connection to a list of items."""
type DayConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [DayEdge]!
  aggregate: AggregateDay!
}

input DayCreateInput {
  dayName: WEEKDAY!
  shifts: ShiftCreateManyInput
}

input DayCreateManyInput {
  create: [DayCreateInput!]
  connect: [DayWhereUniqueInput!]
}

"""An edge in a connection."""
type DayEdge {
  """The item at the end of the edge."""
  node: Day!

  """A cursor for use in pagination."""
  cursor: String!
}

enum DayOrderByInput {
  id_ASC
  id_DESC
  dayName_ASC
  dayName_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type DayPreviousValues {
  id: ID!
  dayName: WEEKDAY!
}

type DaySubscriptionPayload {
  mutation: MutationType!
  node: Day
  updatedFields: [String!]
  previousValues: DayPreviousValues
}

input DaySubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [DaySubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [DaySubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [DaySubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: DayWhereInput
}

input DayUpdateDataInput {
  dayName: WEEKDAY
  shifts: ShiftUpdateManyInput
}

input DayUpdateInput {
  dayName: WEEKDAY
  shifts: ShiftUpdateManyInput
}

input DayUpdateManyInput {
  create: [DayCreateInput!]
  connect: [DayWhereUniqueInput!]
  disconnect: [DayWhereUniqueInput!]
  delete: [DayWhereUniqueInput!]
  update: [DayUpdateWithWhereUniqueNestedInput!]
  upsert: [DayUpsertWithWhereUniqueNestedInput!]
}

input DayUpdateWithWhereUniqueNestedInput {
  where: DayWhereUniqueInput!
  data: DayUpdateDataInput!
}

input DayUpsertWithWhereUniqueNestedInput {
  where: DayWhereUniqueInput!
  update: DayUpdateDataInput!
  create: DayCreateInput!
}

input DayWhereInput {
  """Logical AND on all given filters."""
  AND: [DayWhereInput!]

  """Logical OR on all given filters."""
  OR: [DayWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [DayWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  dayName: WEEKDAY

  """All values that are not equal to given value."""
  dayName_not: WEEKDAY

  """All values that are contained in given list."""
  dayName_in: [WEEKDAY!]

  """All values that are not contained in given list."""
  dayName_not_in: [WEEKDAY!]
  shifts_every: ShiftWhereInput
  shifts_some: ShiftWhereInput
  shifts_none: ShiftWhereInput
  _MagicalBackRelation_DaysOfSchedule_every: ScheduleWhereInput
  _MagicalBackRelation_DaysOfSchedule_some: ScheduleWhereInput
  _MagicalBackRelation_DaysOfSchedule_none: ScheduleWhereInput
}

input DayWhereUniqueInput {
  id: ID
}

"""
The `Long` scalar type represents non-fractional signed whole numeric values.
Long can represent values between -(2^63) and 2^63 - 1.
"""
scalar Long

type Mutation {
  createUser(data: UserCreateInput!): User!
  createSchedule(data: ScheduleCreateInput!): Schedule!
  createUserAvailability(data: UserAvailabilityCreateInput!): UserAvailability!
  createShift(data: ShiftCreateInput!): Shift!
  createDay(data: DayCreateInput!): Day!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateSchedule(data: ScheduleUpdateInput!, where: ScheduleWhereUniqueInput!): Schedule
  updateUserAvailability(data: UserAvailabilityUpdateInput!, where: UserAvailabilityWhereUniqueInput!): UserAvailability
  updateShift(data: ShiftUpdateInput!, where: ShiftWhereUniqueInput!): Shift
  updateDay(data: DayUpdateInput!, where: DayWhereUniqueInput!): Day
  deleteUser(where: UserWhereUniqueInput!): User
  deleteSchedule(where: ScheduleWhereUniqueInput!): Schedule
  deleteUserAvailability(where: UserAvailabilityWhereUniqueInput!): UserAvailability
  deleteShift(where: ShiftWhereUniqueInput!): Shift
  deleteDay(where: DayWhereUniqueInput!): Day
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  upsertSchedule(where: ScheduleWhereUniqueInput!, create: ScheduleCreateInput!, update: ScheduleUpdateInput!): Schedule!
  upsertUserAvailability(where: UserAvailabilityWhereUniqueInput!, create: UserAvailabilityCreateInput!, update: UserAvailabilityUpdateInput!): UserAvailability!
  upsertShift(where: ShiftWhereUniqueInput!, create: ShiftCreateInput!, update: ShiftUpdateInput!): Shift!
  upsertDay(where: DayWhereUniqueInput!, create: DayCreateInput!, update: DayUpdateInput!): Day!
  updateManyUsers(data: UserUpdateInput!, where: UserWhereInput): BatchPayload!
  updateManySchedules(data: ScheduleUpdateInput!, where: ScheduleWhereInput): BatchPayload!
  updateManyUserAvailabilities(data: UserAvailabilityUpdateInput!, where: UserAvailabilityWhereInput): BatchPayload!
  updateManyShifts(data: ShiftUpdateInput!, where: ShiftWhereInput): BatchPayload!
  updateManyDays(data: DayUpdateInput!, where: DayWhereInput): BatchPayload!
  deleteManyUsers(where: UserWhereInput): BatchPayload!
  deleteManySchedules(where: ScheduleWhereInput): BatchPayload!
  deleteManyUserAvailabilities(where: UserAvailabilityWhereInput): BatchPayload!
  deleteManyShifts(where: ShiftWhereInput): BatchPayload!
  deleteManyDays(where: DayWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

"""An object with an ID"""
interface Node {
  """The id of the object."""
  id: ID!
}

"""Information about pagination in a connection."""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String

  """When paginating forwards, the cursor to continue."""
  endCursor: String
}

type Query {
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  schedules(where: ScheduleWhereInput, orderBy: ScheduleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Schedule]!
  userAvailabilities(where: UserAvailabilityWhereInput, orderBy: UserAvailabilityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [UserAvailability]!
  shifts(where: ShiftWhereInput, orderBy: ShiftOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Shift]!
  days(where: DayWhereInput, orderBy: DayOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Day]!
  user(where: UserWhereUniqueInput!): User
  schedule(where: ScheduleWhereUniqueInput!): Schedule
  userAvailability(where: UserAvailabilityWhereUniqueInput!): UserAvailability
  shift(where: ShiftWhereUniqueInput!): Shift
  day(where: DayWhereUniqueInput!): Day
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  schedulesConnection(where: ScheduleWhereInput, orderBy: ScheduleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ScheduleConnection!
  userAvailabilitiesConnection(where: UserAvailabilityWhereInput, orderBy: UserAvailabilityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserAvailabilityConnection!
  shiftsConnection(where: ShiftWhereInput, orderBy: ShiftOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ShiftConnection!
  daysConnection(where: DayWhereInput, orderBy: DayOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): DayConnection!

  """Fetches an object given its ID"""
  node(
    """The ID of an object"""
    id: ID!
  ): Node
}

enum ROLE {
  Employee
  Admin
}

type Schedule implements Node {
  id: ID!
  weekNo: Int!
  week(where: DayWhereInput, orderBy: DayOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Day!]
}

"""A connection to a list of items."""
type ScheduleConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [ScheduleEdge]!
  aggregate: AggregateSchedule!
}

input ScheduleCreateInput {
  weekNo: Int!
  week: DayCreateManyInput
}

"""An edge in a connection."""
type ScheduleEdge {
  """The item at the end of the edge."""
  node: Schedule!

  """A cursor for use in pagination."""
  cursor: String!
}

enum ScheduleOrderByInput {
  id_ASC
  id_DESC
  weekNo_ASC
  weekNo_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type SchedulePreviousValues {
  id: ID!
  weekNo: Int!
}

type ScheduleSubscriptionPayload {
  mutation: MutationType!
  node: Schedule
  updatedFields: [String!]
  previousValues: SchedulePreviousValues
}

input ScheduleSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [ScheduleSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [ScheduleSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [ScheduleSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: ScheduleWhereInput
}

input ScheduleUpdateInput {
  weekNo: Int
  week: DayUpdateManyInput
}

input ScheduleWhereInput {
  """Logical AND on all given filters."""
  AND: [ScheduleWhereInput!]

  """Logical OR on all given filters."""
  OR: [ScheduleWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [ScheduleWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  weekNo: Int

  """All values that are not equal to given value."""
  weekNo_not: Int

  """All values that are contained in given list."""
  weekNo_in: [Int!]

  """All values that are not contained in given list."""
  weekNo_not_in: [Int!]

  """All values less than the given value."""
  weekNo_lt: Int

  """All values less than or equal the given value."""
  weekNo_lte: Int

  """All values greater than the given value."""
  weekNo_gt: Int

  """All values greater than or equal the given value."""
  weekNo_gte: Int
  week_every: DayWhereInput
  week_some: DayWhereInput
  week_none: DayWhereInput
}

input ScheduleWhereUniqueInput {
  id: ID
}

type Shift implements Node {
  id: ID!
  startTime: Int!
  endTime: Int!
  availabilities(where: UserAvailabilityWhereInput, orderBy: UserAvailabilityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [UserAvailability!]
  scheduled(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
}

"""A connection to a list of items."""
type ShiftConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [ShiftEdge]!
  aggregate: AggregateShift!
}

input ShiftCreateInput {
  startTime: Int!
  endTime: Int!
  availabilities: UserAvailabilityCreateManyWithoutShiftInput
  scheduled: UserCreateManyWithoutScheduledInput
}

input ShiftCreateManyInput {
  create: [ShiftCreateInput!]
  connect: [ShiftWhereUniqueInput!]
}

input ShiftCreateManyWithoutScheduledInput {
  create: [ShiftCreateWithoutScheduledInput!]
  connect: [ShiftWhereUniqueInput!]
}

input ShiftCreateOneWithoutAvailabilitiesInput {
  create: ShiftCreateWithoutAvailabilitiesInput
  connect: ShiftWhereUniqueInput
}

input ShiftCreateWithoutAvailabilitiesInput {
  startTime: Int!
  endTime: Int!
  scheduled: UserCreateManyWithoutScheduledInput
}

input ShiftCreateWithoutScheduledInput {
  startTime: Int!
  endTime: Int!
  availabilities: UserAvailabilityCreateManyWithoutShiftInput
}

"""An edge in a connection."""
type ShiftEdge {
  """The item at the end of the edge."""
  node: Shift!

  """A cursor for use in pagination."""
  cursor: String!
}

enum ShiftOrderByInput {
  id_ASC
  id_DESC
  startTime_ASC
  startTime_DESC
  endTime_ASC
  endTime_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type ShiftPreviousValues {
  id: ID!
  startTime: Int!
  endTime: Int!
}

type ShiftSubscriptionPayload {
  mutation: MutationType!
  node: Shift
  updatedFields: [String!]
  previousValues: ShiftPreviousValues
}

input ShiftSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [ShiftSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [ShiftSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [ShiftSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: ShiftWhereInput
}

input ShiftUpdateDataInput {
  startTime: Int
  endTime: Int
  availabilities: UserAvailabilityUpdateManyWithoutShiftInput
  scheduled: UserUpdateManyWithoutScheduledInput
}

input ShiftUpdateInput {
  startTime: Int
  endTime: Int
  availabilities: UserAvailabilityUpdateManyWithoutShiftInput
  scheduled: UserUpdateManyWithoutScheduledInput
}

input ShiftUpdateManyInput {
  create: [ShiftCreateInput!]
  connect: [ShiftWhereUniqueInput!]
  disconnect: [ShiftWhereUniqueInput!]
  delete: [ShiftWhereUniqueInput!]
  update: [ShiftUpdateWithWhereUniqueNestedInput!]
  upsert: [ShiftUpsertWithWhereUniqueNestedInput!]
}

input ShiftUpdateManyWithoutScheduledInput {
  create: [ShiftCreateWithoutScheduledInput!]
  connect: [ShiftWhereUniqueInput!]
  disconnect: [ShiftWhereUniqueInput!]
  delete: [ShiftWhereUniqueInput!]
  update: [ShiftUpdateWithWhereUniqueWithoutScheduledInput!]
  upsert: [ShiftUpsertWithWhereUniqueWithoutScheduledInput!]
}

input ShiftUpdateOneWithoutAvailabilitiesInput {
  create: ShiftCreateWithoutAvailabilitiesInput
  connect: ShiftWhereUniqueInput
  delete: Boolean
  update: ShiftUpdateWithoutAvailabilitiesDataInput
  upsert: ShiftUpsertWithoutAvailabilitiesInput
}

input ShiftUpdateWithoutAvailabilitiesDataInput {
  startTime: Int
  endTime: Int
  scheduled: UserUpdateManyWithoutScheduledInput
}

input ShiftUpdateWithoutScheduledDataInput {
  startTime: Int
  endTime: Int
  availabilities: UserAvailabilityUpdateManyWithoutShiftInput
}

input ShiftUpdateWithWhereUniqueNestedInput {
  where: ShiftWhereUniqueInput!
  data: ShiftUpdateDataInput!
}

input ShiftUpdateWithWhereUniqueWithoutScheduledInput {
  where: ShiftWhereUniqueInput!
  data: ShiftUpdateWithoutScheduledDataInput!
}

input ShiftUpsertWithoutAvailabilitiesInput {
  update: ShiftUpdateWithoutAvailabilitiesDataInput!
  create: ShiftCreateWithoutAvailabilitiesInput!
}

input ShiftUpsertWithWhereUniqueNestedInput {
  where: ShiftWhereUniqueInput!
  update: ShiftUpdateDataInput!
  create: ShiftCreateInput!
}

input ShiftUpsertWithWhereUniqueWithoutScheduledInput {
  where: ShiftWhereUniqueInput!
  update: ShiftUpdateWithoutScheduledDataInput!
  create: ShiftCreateWithoutScheduledInput!
}

input ShiftWhereInput {
  """Logical AND on all given filters."""
  AND: [ShiftWhereInput!]

  """Logical OR on all given filters."""
  OR: [ShiftWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [ShiftWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  startTime: Int

  """All values that are not equal to given value."""
  startTime_not: Int

  """All values that are contained in given list."""
  startTime_in: [Int!]

  """All values that are not contained in given list."""
  startTime_not_in: [Int!]

  """All values less than the given value."""
  startTime_lt: Int

  """All values less than or equal the given value."""
  startTime_lte: Int

  """All values greater than the given value."""
  startTime_gt: Int

  """All values greater than or equal the given value."""
  startTime_gte: Int
  endTime: Int

  """All values that are not equal to given value."""
  endTime_not: Int

  """All values that are contained in given list."""
  endTime_in: [Int!]

  """All values that are not contained in given list."""
  endTime_not_in: [Int!]

  """All values less than the given value."""
  endTime_lt: Int

  """All values less than or equal the given value."""
  endTime_lte: Int

  """All values greater than the given value."""
  endTime_gt: Int

  """All values greater than or equal the given value."""
  endTime_gte: Int
  availabilities_every: UserAvailabilityWhereInput
  availabilities_some: UserAvailabilityWhereInput
  availabilities_none: UserAvailabilityWhereInput
  scheduled_every: UserWhereInput
  scheduled_some: UserWhereInput
  scheduled_none: UserWhereInput
  _MagicalBackRelation_ShiftsOfDay_every: DayWhereInput
  _MagicalBackRelation_ShiftsOfDay_some: DayWhereInput
  _MagicalBackRelation_ShiftsOfDay_none: DayWhereInput
}

input ShiftWhereUniqueInput {
  id: ID
}

type Subscription {
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
  schedule(where: ScheduleSubscriptionWhereInput): ScheduleSubscriptionPayload
  userAvailability(where: UserAvailabilitySubscriptionWhereInput): UserAvailabilitySubscriptionPayload
  shift(where: ShiftSubscriptionWhereInput): ShiftSubscriptionPayload
  day(where: DaySubscriptionWhereInput): DaySubscriptionPayload
}

type User implements Node {
  id: ID!
  netid: String!
  firstName: String
  lastName: String
  idealHour: Int
  maxHour: Int
  totalHours: Int
  role: ROLE!
  availabilities(where: UserAvailabilityWhereInput, orderBy: UserAvailabilityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [UserAvailability!]
  scheduled(where: ShiftWhereInput, orderBy: ShiftOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Shift!]
}

type UserAvailability implements Node {
  id: ID!
  shift(where: ShiftWhereInput): Shift!
  user(where: UserWhereInput): User!
  availability: Int
}

"""A connection to a list of items."""
type UserAvailabilityConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [UserAvailabilityEdge]!
  aggregate: AggregateUserAvailability!
}

input UserAvailabilityCreateInput {
  availability: Int
  shift: ShiftCreateOneWithoutAvailabilitiesInput!
  user: UserCreateOneWithoutAvailabilitiesInput!
}

input UserAvailabilityCreateManyWithoutShiftInput {
  create: [UserAvailabilityCreateWithoutShiftInput!]
  connect: [UserAvailabilityWhereUniqueInput!]
}

input UserAvailabilityCreateManyWithoutUserInput {
  create: [UserAvailabilityCreateWithoutUserInput!]
  connect: [UserAvailabilityWhereUniqueInput!]
}

input UserAvailabilityCreateWithoutShiftInput {
  availability: Int
  user: UserCreateOneWithoutAvailabilitiesInput!
}

input UserAvailabilityCreateWithoutUserInput {
  availability: Int
  shift: ShiftCreateOneWithoutAvailabilitiesInput!
}

"""An edge in a connection."""
type UserAvailabilityEdge {
  """The item at the end of the edge."""
  node: UserAvailability!

  """A cursor for use in pagination."""
  cursor: String!
}

enum UserAvailabilityOrderByInput {
  id_ASC
  id_DESC
  availability_ASC
  availability_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type UserAvailabilityPreviousValues {
  id: ID!
  availability: Int
}

type UserAvailabilitySubscriptionPayload {
  mutation: MutationType!
  node: UserAvailability
  updatedFields: [String!]
  previousValues: UserAvailabilityPreviousValues
}

input UserAvailabilitySubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [UserAvailabilitySubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [UserAvailabilitySubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [UserAvailabilitySubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: UserAvailabilityWhereInput
}

input UserAvailabilityUpdateInput {
  availability: Int
  shift: ShiftUpdateOneWithoutAvailabilitiesInput
  user: UserUpdateOneWithoutAvailabilitiesInput
}

input UserAvailabilityUpdateManyWithoutShiftInput {
  create: [UserAvailabilityCreateWithoutShiftInput!]
  connect: [UserAvailabilityWhereUniqueInput!]
  disconnect: [UserAvailabilityWhereUniqueInput!]
  delete: [UserAvailabilityWhereUniqueInput!]
  update: [UserAvailabilityUpdateWithWhereUniqueWithoutShiftInput!]
  upsert: [UserAvailabilityUpsertWithWhereUniqueWithoutShiftInput!]
}

input UserAvailabilityUpdateManyWithoutUserInput {
  create: [UserAvailabilityCreateWithoutUserInput!]
  connect: [UserAvailabilityWhereUniqueInput!]
  disconnect: [UserAvailabilityWhereUniqueInput!]
  delete: [UserAvailabilityWhereUniqueInput!]
  update: [UserAvailabilityUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [UserAvailabilityUpsertWithWhereUniqueWithoutUserInput!]
}

input UserAvailabilityUpdateWithoutShiftDataInput {
  availability: Int
  user: UserUpdateOneWithoutAvailabilitiesInput
}

input UserAvailabilityUpdateWithoutUserDataInput {
  availability: Int
  shift: ShiftUpdateOneWithoutAvailabilitiesInput
}

input UserAvailabilityUpdateWithWhereUniqueWithoutShiftInput {
  where: UserAvailabilityWhereUniqueInput!
  data: UserAvailabilityUpdateWithoutShiftDataInput!
}

input UserAvailabilityUpdateWithWhereUniqueWithoutUserInput {
  where: UserAvailabilityWhereUniqueInput!
  data: UserAvailabilityUpdateWithoutUserDataInput!
}

input UserAvailabilityUpsertWithWhereUniqueWithoutShiftInput {
  where: UserAvailabilityWhereUniqueInput!
  update: UserAvailabilityUpdateWithoutShiftDataInput!
  create: UserAvailabilityCreateWithoutShiftInput!
}

input UserAvailabilityUpsertWithWhereUniqueWithoutUserInput {
  where: UserAvailabilityWhereUniqueInput!
  update: UserAvailabilityUpdateWithoutUserDataInput!
  create: UserAvailabilityCreateWithoutUserInput!
}

input UserAvailabilityWhereInput {
  """Logical AND on all given filters."""
  AND: [UserAvailabilityWhereInput!]

  """Logical OR on all given filters."""
  OR: [UserAvailabilityWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [UserAvailabilityWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  availability: Int

  """All values that are not equal to given value."""
  availability_not: Int

  """All values that are contained in given list."""
  availability_in: [Int!]

  """All values that are not contained in given list."""
  availability_not_in: [Int!]

  """All values less than the given value."""
  availability_lt: Int

  """All values less than or equal the given value."""
  availability_lte: Int

  """All values greater than the given value."""
  availability_gt: Int

  """All values greater than or equal the given value."""
  availability_gte: Int
  shift: ShiftWhereInput
  user: UserWhereInput
}

input UserAvailabilityWhereUniqueInput {
  id: ID
}

"""A connection to a list of items."""
type UserConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  netid: String!
  firstName: String
  lastName: String
  idealHour: Int
  maxHour: Int
  totalHours: Int
  role: ROLE
  availabilities: UserAvailabilityCreateManyWithoutUserInput
  scheduled: ShiftCreateManyWithoutScheduledInput
}

input UserCreateManyWithoutScheduledInput {
  create: [UserCreateWithoutScheduledInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateOneWithoutAvailabilitiesInput {
  create: UserCreateWithoutAvailabilitiesInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutAvailabilitiesInput {
  netid: String!
  firstName: String
  lastName: String
  idealHour: Int
  maxHour: Int
  totalHours: Int
  role: ROLE
  scheduled: ShiftCreateManyWithoutScheduledInput
}

input UserCreateWithoutScheduledInput {
  netid: String!
  firstName: String
  lastName: String
  idealHour: Int
  maxHour: Int
  totalHours: Int
  role: ROLE
  availabilities: UserAvailabilityCreateManyWithoutUserInput
}

"""An edge in a connection."""
type UserEdge {
  """The item at the end of the edge."""
  node: User!

  """A cursor for use in pagination."""
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  netid_ASC
  netid_DESC
  firstName_ASC
  firstName_DESC
  lastName_ASC
  lastName_DESC
  idealHour_ASC
  idealHour_DESC
  maxHour_ASC
  maxHour_DESC
  totalHours_ASC
  totalHours_DESC
  role_ASC
  role_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type UserPreviousValues {
  id: ID!
  netid: String!
  firstName: String
  lastName: String
  idealHour: Int
  maxHour: Int
  totalHours: Int
  role: ROLE!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [UserSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [UserSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [UserSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: UserWhereInput
}

input UserUpdateInput {
  netid: String
  firstName: String
  lastName: String
  idealHour: Int
  maxHour: Int
  totalHours: Int
  role: ROLE
  availabilities: UserAvailabilityUpdateManyWithoutUserInput
  scheduled: ShiftUpdateManyWithoutScheduledInput
}

input UserUpdateManyWithoutScheduledInput {
  create: [UserCreateWithoutScheduledInput!]
  connect: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  delete: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutScheduledInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutScheduledInput!]
}

input UserUpdateOneWithoutAvailabilitiesInput {
  create: UserCreateWithoutAvailabilitiesInput
  connect: UserWhereUniqueInput
  delete: Boolean
  update: UserUpdateWithoutAvailabilitiesDataInput
  upsert: UserUpsertWithoutAvailabilitiesInput
}

input UserUpdateWithoutAvailabilitiesDataInput {
  netid: String
  firstName: String
  lastName: String
  idealHour: Int
  maxHour: Int
  totalHours: Int
  role: ROLE
  scheduled: ShiftUpdateManyWithoutScheduledInput
}

input UserUpdateWithoutScheduledDataInput {
  netid: String
  firstName: String
  lastName: String
  idealHour: Int
  maxHour: Int
  totalHours: Int
  role: ROLE
  availabilities: UserAvailabilityUpdateManyWithoutUserInput
}

input UserUpdateWithWhereUniqueWithoutScheduledInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutScheduledDataInput!
}

input UserUpsertWithoutAvailabilitiesInput {
  update: UserUpdateWithoutAvailabilitiesDataInput!
  create: UserCreateWithoutAvailabilitiesInput!
}

input UserUpsertWithWhereUniqueWithoutScheduledInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutScheduledDataInput!
  create: UserCreateWithoutScheduledInput!
}

input UserWhereInput {
  """Logical AND on all given filters."""
  AND: [UserWhereInput!]

  """Logical OR on all given filters."""
  OR: [UserWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [UserWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  netid: String

  """All values that are not equal to given value."""
  netid_not: String

  """All values that are contained in given list."""
  netid_in: [String!]

  """All values that are not contained in given list."""
  netid_not_in: [String!]

  """All values less than the given value."""
  netid_lt: String

  """All values less than or equal the given value."""
  netid_lte: String

  """All values greater than the given value."""
  netid_gt: String

  """All values greater than or equal the given value."""
  netid_gte: String

  """All values containing the given string."""
  netid_contains: String

  """All values not containing the given string."""
  netid_not_contains: String

  """All values starting with the given string."""
  netid_starts_with: String

  """All values not starting with the given string."""
  netid_not_starts_with: String

  """All values ending with the given string."""
  netid_ends_with: String

  """All values not ending with the given string."""
  netid_not_ends_with: String
  firstName: String

  """All values that are not equal to given value."""
  firstName_not: String

  """All values that are contained in given list."""
  firstName_in: [String!]

  """All values that are not contained in given list."""
  firstName_not_in: [String!]

  """All values less than the given value."""
  firstName_lt: String

  """All values less than or equal the given value."""
  firstName_lte: String

  """All values greater than the given value."""
  firstName_gt: String

  """All values greater than or equal the given value."""
  firstName_gte: String

  """All values containing the given string."""
  firstName_contains: String

  """All values not containing the given string."""
  firstName_not_contains: String

  """All values starting with the given string."""
  firstName_starts_with: String

  """All values not starting with the given string."""
  firstName_not_starts_with: String

  """All values ending with the given string."""
  firstName_ends_with: String

  """All values not ending with the given string."""
  firstName_not_ends_with: String
  lastName: String

  """All values that are not equal to given value."""
  lastName_not: String

  """All values that are contained in given list."""
  lastName_in: [String!]

  """All values that are not contained in given list."""
  lastName_not_in: [String!]

  """All values less than the given value."""
  lastName_lt: String

  """All values less than or equal the given value."""
  lastName_lte: String

  """All values greater than the given value."""
  lastName_gt: String

  """All values greater than or equal the given value."""
  lastName_gte: String

  """All values containing the given string."""
  lastName_contains: String

  """All values not containing the given string."""
  lastName_not_contains: String

  """All values starting with the given string."""
  lastName_starts_with: String

  """All values not starting with the given string."""
  lastName_not_starts_with: String

  """All values ending with the given string."""
  lastName_ends_with: String

  """All values not ending with the given string."""
  lastName_not_ends_with: String
  idealHour: Int

  """All values that are not equal to given value."""
  idealHour_not: Int

  """All values that are contained in given list."""
  idealHour_in: [Int!]

  """All values that are not contained in given list."""
  idealHour_not_in: [Int!]

  """All values less than the given value."""
  idealHour_lt: Int

  """All values less than or equal the given value."""
  idealHour_lte: Int

  """All values greater than the given value."""
  idealHour_gt: Int

  """All values greater than or equal the given value."""
  idealHour_gte: Int
  maxHour: Int

  """All values that are not equal to given value."""
  maxHour_not: Int

  """All values that are contained in given list."""
  maxHour_in: [Int!]

  """All values that are not contained in given list."""
  maxHour_not_in: [Int!]

  """All values less than the given value."""
  maxHour_lt: Int

  """All values less than or equal the given value."""
  maxHour_lte: Int

  """All values greater than the given value."""
  maxHour_gt: Int

  """All values greater than or equal the given value."""
  maxHour_gte: Int
  totalHours: Int

  """All values that are not equal to given value."""
  totalHours_not: Int

  """All values that are contained in given list."""
  totalHours_in: [Int!]

  """All values that are not contained in given list."""
  totalHours_not_in: [Int!]

  """All values less than the given value."""
  totalHours_lt: Int

  """All values less than or equal the given value."""
  totalHours_lte: Int

  """All values greater than the given value."""
  totalHours_gt: Int

  """All values greater than or equal the given value."""
  totalHours_gte: Int
  role: ROLE

  """All values that are not equal to given value."""
  role_not: ROLE

  """All values that are contained in given list."""
  role_in: [ROLE!]

  """All values that are not contained in given list."""
  role_not_in: [ROLE!]
  availabilities_every: UserAvailabilityWhereInput
  availabilities_some: UserAvailabilityWhereInput
  availabilities_none: UserAvailabilityWhereInput
  scheduled_every: ShiftWhereInput
  scheduled_some: ShiftWhereInput
  scheduled_none: ShiftWhereInput
}

input UserWhereUniqueInput {
  id: ID
  netid: String
}

enum WEEKDAY {
  Monday
  Tuesday
  Wednesday
  Thursday
  Friday
  Saturday
  Sunday
}
